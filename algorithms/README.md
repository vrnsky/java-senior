# Этот модуль содержит примеры реализации различных алгоритмов и структур данных на Java:

## Общие понятия об алгоритмах
Алгоритмом называют последовательность операции шагов, выполнив которые мы получим определенный результат. Не будем вдаваться в подробности термина, но для тех, кто хочет более детального описания - [Алгоритм](https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC)

Скорость выполнения алгоритма оценивается с помощью специальной нотации называющейся О - большое, которое показывает как растет количество операции в алгоритме с увелечением входных данных.

## Бинарный поиск
Бинарный поиск - из названия уже понятно, что это алгоритм для поиска. Суть данного алгоритма заключается в следующем: допустим, у нас массив, в который нам нужно найти индекс какого-то элемента. Есть важное ограничение, прежде чем пользоваться даннным алгоритмом необходимо отсортировать список, так как бинарный поиск не работает на несортированных данных. Если массив отсортирован, то может приступать к поиску. Искать будем следующем образом:
1. Находим середину списка или массива то есть: ```(middle=array.length-low)/2```
2. Сраванием элемент находящий по array[middle] с искомым элементом и действуем следующим образом
3. Если array[middle] оказался больше, чем искомый элемент, то двигаем указаль middle присваиваем значение равное high -1
4. В противном случае устанавливаем значением low = middle + 1
5. Повторяем шаги 1-4 до тех пор пока low <= high

## Сортировка выбором
Оценка эффективности - в худшем случае ```O(n^2)```
Данный алгоритм работает следующим образом:
1. Находим индекс самого минимального элемента
2. Получаем значение хранящееся по этому индексу в массиве
3. Сохраняем значение в массиве, который хранит сортированные элементы.
4. Удаляем элементы с таким индексом из оригинального массива
5. Повторяем шаги 2-4 до тех пор, пока массив не пуст


## Сортировка пузырьком
Данный алгоримт имеет оценку эффективности ```O(n^2)``` (используеться вложенный for)
1. В цикле получаем элемент, начиная с начала массива
2. Делаем еще один цикл, в котором обходим массив, но начинаем со следующего элемента
3. Сравниваем элементы полученные в шагах 1 и 2.
4. Если элемент полученный в шаге 2 оказался меньше элемента, полученного в шаге 1, то меняем элементы местами

## Быстрая сортировка
Данный алгоритм работает в стандартной библиотеке java ```java.lang.util.Collections.sort```
Имеет оценку эффективности ```O(nlog(n))```
1. Выбираем какой-то опорный элемент(лучшим кандидатом для этого дела является центральный элемент)
2. Слева от выбранного элемента собираем все элементы, что меньше опорного
3. Справа от выбранного элемента собираем все элементы, что больше опорного.
4. Повторяем шаги 1-3 до тех, пор пока не дойдем до массива с одним элементом.

## Поиск в глубину
Данный алгоритм применим к такой структре данных как графы. Возьмем для рассмотрения граф друзей человека
Будем искать среди друзей, друзей друзей, друзей друзей друзей и т.д...продавца шаурмы
1. Сначал проверяем, что среди наших друзей или друзей друга нет продавцов шаурмы
2. Если продавец шаурмы все-таки есть, то поиски завершены. 
3. Если продавца нет, то спускаем на уровень ниже, то есть ищем среди друзей ваших друзей.
4. Повторяем шаги 1-3 до тех пор, пока не закончим поиски

## Жадный алгоритм
Данный алгоритм призван помочь найти не идеальное, но локально-оптимальное решение в расчете 
на то, что глобальный оптимум. Разберем на примере загрузке грузовика коробками различных размеров
1. Среди всех коробок находим самую большую и помещаем ее в грузовик
2. Ищем среди оставшихся коробок опять же самую большую и помещаем ее в грузовик
3. Повторяем шаги 1-2 до тех пор, пока у нас остались коробки или осталось место в грузовике.

## Динамическое программирование
Динамическое программирование - это решение проблемы путем разбиения ее на подпроблемы.
Обязательное условие, чтобы подпроблемы были автономны. 

Динамическое программирование применяется при оптимизации некоторой характеристики
Не существует единой формулы для вычисления решений методом динамического программирования​
Парадигма динамического программирования используется в таких алгоритмах как поиск наибольшей подстроки

## Алгоритм ближайших k соседей
С помощью этого алгоритма можно построить свою рекомендательную систему.
Сейчас будет то, как упрощенно как работают рекомендации на Netflix

1. При регистрации пользователю предлагают оценить фильмы/жанры, то есть конвертируем пользователя в цифры
2. Далее с помощью пифагора находим пользователей со схожими вкусами
3. Предлагаем пользователю посмотреть то, что посмотрел его сосед, с учетом тех жанров и фильмов, что нравятся пользователю​​

## Преобразование Фурье
Насколько я понял из книги, и из воспоминании времени моей учебы. То на пальцах объясняя, оно помогает
 нам узнать из каких ингредиентов приготовлен коктейль или из аудиофайлы вычислить низкие и высоки частоты и манипулировать уже ими.

## MapReduce
Данная парадигма несет все очень простые две вещи, функция map применяет что-то
ко всем элементам массива,а функция reduce отображает что-то.

## SHA
Расшифровывается как Security Hash Algorithm. Данный алгоритм нужен нам для шифрования
паролей и прочей секьюрной информации. На вход подается какая-то строка, а на выходе получаем хэш этой строки, то есть god -> 2aec4f....

Данный алгоритм работает только в одну сторону, невозможно из хэша сделать строчку, так-же этот алгоритм 
является локально-нечувствительным, то есть на строчку dog и на строчку dot будут сгенерированы абсолютно два разных хэша

## Фильтры Блума
Данные фильтры нужны нам для того, чтобы ускорить работу какого-либо сервиса. Например, нам нужно проверять не находиться ли сайт в списке подозрительных. Проблема в том, что в базе у нас может храниться очень много сайтов и поиск по всем займет очень много времени. Фильтры Блума позволяют нам сделать некоторое предположение. Фильтр не идеален, и поэтому иногда бывают ложно-позитивные срабатывания, то есть фильтр говорит, что сайт уже обрабатывался, хотя такого не было, а вот ложно отрицательные срабатывания исключены, то есть если наш фильтр говорит, что сайт не обрабатывался, значит он действительно не обрабатывался

## OCR
Расшифровывается как Optical Character Recognition - данный алгоритм используется в Google Переводчик,
для того, чтобы переводить сразу с бумажки. Работает он примерно следующим образом - изначально задаются какие-то очертания букв и при анализе изображения проводится сравнительный анализ то, что есть у алгоритма и то, что на бумаге и на основе этого анализа пытается построить букву

## Интерфейс List
Существует две основных реализации:
1. ArrayList - динамический спискок, внутри работает на обычном массиве.
2. LinkedList - динамический список, внутри работает как связный список,
каждый элемент хранит ссылку на предыдущий и на следующий элемент.
3. Vector - тот же самый ArrayList, только потокобезопасный, и проигрывает по производительности.
Проигрывает потому, что при увелечении размера внутреннего массива Vector увелелчивает его в 2 раза,
а ArrayList увеличивает на на 2/3 от размера текущего используемого массива.

## Интерфейс Set
Существует две основных реализации:
1. HashSet - множество, основанное на hash фукнции, внутри используется HashMap,
а точнее только ключи - ключ в Map'e должен быть обязательно уникальным.
2. TreeSet - множество, основанное на такой структуре как дерево. Не дружит с типами,
которые не реализовывают интерфейс Comparable - будет выброшено исключение ClassCastException
Можно также задать метод сравнения при создании данной коллекции, передав реализацию интерфейса Comparator

## Интерфейс Queue
Данный интерфейс предназачене для хранения элементов перед их обработкой.
Реализуют принцип FIFO(first in - first out), то есть элемент, который был добавлен раньше
будет выдан раньньше. Существуют также наследник этого класса Deque, называется он
так потому, что double ended (de в начале) queue. Deque позволяет работать с очередью с обоих концов.
Важно отметить, что в реализациях данных коллекции существует две версии методов
для выполнения основных операции. Одна версия возвращает специальное значение, а другая бросает исключение
Основные реализации:
1. ArrayDeque - очередь, основанная на массиве.
2. PriorityDeque - очередь, которая сортирует элементы в порядке их приоритетов.
Приоритет - это некоторый признак, по котому можно было бы сравнить добавляемый
объект с тем, что уже есть в коллекции. Объекты, добавляемые в коллекцию должны обязательно
реализовывать интерфейс Comparable или вы должны явно передать Comparator в конструктор.