# Этот модуль содержит примеры реализации различных алгоритмов на Java:

## Общие понятия об алгоритмах
Алгоритмом называют последовательность операции шагов, выполнив которые мы получим определенный результат. Не будем вдаваться в подробности термина, но для тех, кто хочет более детального описания - [Алгоритм](https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC)

Скорость выполнения алгоритма оценивается с помощью специальной нотации называющейся О - большое, которое показывает как растет количество операции в алгоритме с увелечением входных данных.

## Бинарный поиск
Бинарный поиск - из названия уже понятно, что это алгоритм для поиска. Суть данного алгоритма заключается в следующем: допустим, у нас массив, в который нам нужно найти индекс какого-то элемента. Есть важное ограничение, прежде чем пользоваться даннным алгоритмом необходимо отсортировать список, так как бинарный поиск не работает на несортированных данных. Если массив отсортирован, то может приступать к поиску. Искать будем следующем образом:
1. Находим середину списка или массива то есть: ```(middle=array.length-0)/2```
2. Сраванием элемент находящий по array[middle] с искомым элементом и действуем следующим образом
3. Если array[middle] оказался больше, чем искомый элемент, то двигаем указаль middle присваиваем значение равное high -1
4. В противном случае устанавливаем значением low = middle + 1
5. Повторяем шаги 1-4 до тех пор пока low <= high

## Сортировка выбором
Оценка эффективности - в худшем случае O(n^2)
Данный алгоритм работает следующим образом:
1. Находим индекс самого минимального элемента
2. Получаем значение хранящееся по этому индексу в массиве
3. Сохраняем значение в массиве, который хранит сортированные элементы.
4. Удаляем элементы с таким индексом из оригинального массива
5. Повторяем шаги 2-4 до тех пор, пока массив не пуст


## Сортировка пузырьком
Данный алгоримт имеет оценку эффективности O(n^2)(используеться вложенный for)
1. В цикле получаем элемент, начиная с начала массива
2. Делаем еще один цикл, в котором обходим массив, но начинаем со следующего элемента
3. Сравниваем элементы полученные в шагах 1 и 2.
4. Если элемент полученный в шаге 2 оказался меньше элемента, полученного в шаге 1, то меняем элементы местами

## Быстрая сортировка
Данный алгоритм работает в стандартной библиотеке java ```java.lang.util.Collections.sort```
Имеет оценку эффективности O(nlog(n))
1. Выбираем какой-то опорный элемент(лучшим кандидатом для этого дела является центральный элемент)
2. Слева от выбранного элемента собираем все элементы, что меньше опорного
3. Справа от выбранного элемента собираем все элементы, что больше опорного.
4. Повторяем шаги 1-3 до тех, пор пока не дойдем до массива с одним элементом.

## Поиск в глубину
Данный алгоритм применим к такой структре данных как графы. Возьмем для рассмотрения граф друзей человека
Будем искать среди друзей, друзей друзей, друзей друзей друзей и т.д...продавца шаурмы
1. Сначал проверяем, что среди наших друзей или друзей друга нет продавцов шаурмы
2. Если продавец шаурмы все-таки есть, то поиски завершены. 
3. Если продавца нет, то спускаем на уровень ниже, то есть ищем среди друзей ваших друзей.
4. Повторяем шаги 1-3 до тех пор, пока не закончим поиски

## Жадный алгоритм
Данный алгоритм призван помочь найти не идеальное, но локально-оптимальное решение в расчете 
на то, что глобальный оптимум. Разберем на примере загрузке грузовика коробками различных размеров
1. Среди всех коробок находим самую большую и помещаем ее в грузовик
2. Ищем среди оставшихся коробок опять же самую большую и помещаем ее в грузовик
3. Повторяем шаги 1-2 до тех пор, пока у нас остались коробки или осталось место в грузовике.

